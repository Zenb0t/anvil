#!/bin/sh
# ANVIL — Agent Navigated Verified Implementation Lifecycle
# Minimal CLI for phase-gated agentic SDLC
# Zero dependencies beyond git and POSIX shell
set -e

REPO_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
TEMPLATE_DIR="$REPO_ROOT/process/anvil/templates/feature"
FEATURES_DIR="${FEATURES_DIR:-$REPO_ROOT/work/features}"
PHASES="0-define 1-spec 2-verify 3-build 4-ship"

usage() {
  cat <<'EOF'
Usage: anvil <command> [feature-id]

Commands:
  init <id>       Scaffold a new feature from templates
  status <id> [--json]
                  Print phase status and blockers
  check <id> [--json]
                  Validate current gate (files, checklist, staleness)
  advance <id>    Move to next phase (runs check first)
  list [--json]   List all features with effective phase and gate status
  lint [<id>]     Validate process artifact format and structure

EOF
  exit 1
}

die() { echo "ERROR: $*" >&2; exit 1; }

feature_dir() { echo "$FEATURES_DIR/$1"; }

json_escape() {
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

json_quote() {
  escaped="$(json_escape "$1")"
  printf '"%s"' "$escaped"
}

json_array_from_lines() {
  lines="$1"
  items=""
  while IFS= read -r line; do
    [ -z "$line" ] && continue
    quoted="$(json_quote "$line")"
    if [ -n "$items" ]; then
      items="$items,$quoted"
    else
      items="$quoted"
    fi
  done <<EOF
$lines
EOF
  printf '[%s]' "$items"
}

json_append_item() {
  existing="$1"
  item="$2"
  if [ -n "$existing" ]; then
    printf '%s,%s' "$existing" "$item"
  else
    printf '%s' "$item"
  fi
}

json_optional_string() {
  value="$1"
  if [ -n "$value" ]; then
    json_quote "$value"
  else
    printf 'null'
  fi
}

get_state_anchor() {
  dir="$1"
  phase="$2"
  grep "  $phase:" "$dir/state.yaml" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true
}

# --- init ---
cmd_init() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil init <feature-id>"
  dest="$(feature_dir "$id")"
  [ -d "$dest" ] && die "Feature $id already exists at $dest"

  cp -r "$TEMPLATE_DIR" "$dest"

  # Replace placeholder with actual feature ID
  find "$dest" -type f -name '*.md' -exec sed -i "s/{{FEATURE_ID}}/$id/g" {} +
  sed -i "s/{{FEATURE_ID}}/$id/" "$dest/state.yaml"

  echo "Feature $id scaffolded at $dest"
}

# --- status ---
cmd_status() {
  json_mode=false
  id=""
  for arg in "$@"; do
    case "$arg" in
      --json) json_mode=true ;;
      *)
        if [ -z "$id" ]; then
          id="$arg"
        else
          die "Usage: anvil status <feature-id> [--json]"
        fi
        ;;
    esac
  done

  [ -z "$id" ] && die "Usage: anvil status <feature-id> [--json]"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"
  [ -f "$dir/state.yaml" ] || die "No state.yaml in $dir"

  if ! $json_mode; then
    echo "Feature: $id"
  fi

  # Find effective phase (lowest non-CLEAN)
  effective=""
  phase_items=""
  for phase in $PHASES; do
    phase_status=""
    phase_detail=""
    anchor=""

    gate="$dir/$phase/gate.md"
    if [ ! -f "$gate" ]; then
      [ -z "$effective" ] && effective="$phase"
      phase_status="MISSING"
      phase_detail="no gate.md"
      if ! $json_mode; then
        echo "  $phase: MISSING (no gate.md)"
      fi

      errors_json='["no gate.md"]'
      item="{\"phase\":$(json_quote "$phase"),\"status\":$(json_quote "$phase_status"),\"anchor\":null,\"errors\":$errors_json}"
      phase_items="$(json_append_item "$phase_items" "$item")"
      continue
    fi

    result="$(validate_gate "$dir" "$phase" 2>/dev/null || true)"
    status="$(echo "$result" | head -1)"

    # Read anchor from state.yaml
    anchor="$(get_state_anchor "$dir" "$phase")"

    case "$status" in
      PASS)
        if [ -n "$effective" ]; then
          phase_status="STALE"
          phase_detail="cascade from $effective"
          if ! $json_mode; then
            echo "  $phase: STALE (cascade from $effective)"
          fi
        elif [ -n "$anchor" ]; then
          # Check for staleness
          stale_result="$(check_staleness "$dir" "$phase" "$anchor" 2>/dev/null || true)"
          if [ "$stale_result" = "STALE" ]; then
            [ -z "$effective" ] && effective="$phase"
            phase_status="STALE"
            phase_detail="deps changed since anchor $anchor"
            if ! $json_mode; then
              echo "  $phase: STALE (deps changed since anchor $anchor)"
            fi
          else
            phase_status="CLEAN"
            if ! $json_mode; then
              echo "  $phase: CLEAN (anchor: $anchor)"
            fi
          fi
        else
          phase_status="PASS"
          phase_detail="no anchor"
          if ! $json_mode; then
            echo "  $phase: PASS (no anchor)"
          fi
        fi
        ;;
      *)
        [ -z "$effective" ] && effective="$phase"
        phase_status="$status"
        phase_detail="$(echo "$result" | tail -n +2 | head -3)"
        if ! $json_mode; then
          echo "  $phase: $status"
        fi
        if [ -n "$phase_detail" ] && ! $json_mode; then
          echo "$phase_detail" | sed 's/^/    /'
        fi
        ;;
    esac

    case "$phase_status" in
      CLEAN|PASS) errors_json="[]" ;;
      *)
        if [ -n "$phase_detail" ]; then
          errors_json="$(json_array_from_lines "$phase_detail")"
        else
          errors_json="[]"
        fi
        ;;
    esac

    anchor_json="$(json_optional_string "$anchor")"
    item="{\"phase\":$(json_quote "$phase"),\"status\":$(json_quote "$phase_status"),\"anchor\":$anchor_json,\"errors\":$errors_json}"
    phase_items="$(json_append_item "$phase_items" "$item")"
  done

  if $json_mode; then
    if [ -n "$effective" ]; then
      effective_json="$(json_quote "$effective")"
      all_clean=false
    else
      effective_json="null"
      all_clean=true
    fi
    printf '{"feature":%s,"command":"status","effectivePhase":%s,"allClean":%s,"phases":[%s]}\n' \
      "$(json_quote "$id")" \
      "$effective_json" \
      "$all_clean" \
      "$phase_items"
  else
    if [ -n "$effective" ]; then
      echo ""
      echo "Effective phase: $effective"
    else
      echo ""
      echo "All phases CLEAN."
    fi
  fi
}

# --- check ---
cmd_check() {
  json_mode=false
  id=""
  for arg in "$@"; do
    case "$arg" in
      --json) json_mode=true ;;
      *)
        if [ -z "$id" ]; then
          id="$arg"
        else
          die "Usage: anvil check <feature-id> [--json]"
        fi
        ;;
    esac
  done

  [ -z "$id" ] && die "Usage: anvil check <feature-id> [--json]"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"

  # Validate all gates in order, cascade failures forward
  cascade_from=""
  all_pass=true
  effective=""
  phase_items=""

  for phase in $PHASES; do
    phase_status=""
    phase_detail=""
    anchor_for_json=""

    gate="$dir/$phase/gate.md"
    if [ ! -f "$gate" ]; then
      if ! $json_mode; then
        echo "$phase: MISSING (no gate.md)"
      fi
      phase_status="MISSING"
      phase_detail="no gate.md"
      [ -z "$cascade_from" ] && cascade_from="$phase"
      [ -z "$effective" ] && effective="$phase"
      all_pass=false
      update_state "$dir" "$phase" "fail"
    else
      # If upstream failed, cascade
      if [ -n "$cascade_from" ]; then
        if ! $json_mode; then
          echo "$phase: STALE (cascade from $cascade_from)"
        fi
        phase_status="STALE"
        phase_detail="cascade from $cascade_from"
        [ -z "$effective" ] && effective="$phase"
        all_pass=false
        update_state "$dir" "$phase" "stale"
      else
        result="$(validate_gate "$dir" "$phase")"
        status="$(echo "$result" | head -1)"

        if [ "$status" = "PASS" ]; then
          # Check staleness if anchor exists
          anchor="$(get_state_anchor "$dir" "$phase")"
          if [ -n "$anchor" ]; then
            stale_result="$(check_staleness "$dir" "$phase" "$anchor")"
            if [ "$stale_result" = "STALE" ]; then
              if ! $json_mode; then
                echo "$phase: STALE (deps changed since anchor)"
              fi
              phase_status="STALE"
              phase_detail="deps changed since anchor"
              cascade_from="$phase"
              [ -z "$effective" ] && effective="$phase"
              all_pass=false
              update_state "$dir" "$phase" "stale"
            fi
          fi

          if [ -z "$phase_status" ]; then
            # Check dirty (uncommitted changes to needs)
            dirty_result="$(check_dirty "$dir" "$phase")"
            if [ "$dirty_result" = "DIRTY" ]; then
              if ! $json_mode; then
                echo "$phase: DIRTY (uncommitted changes to deps)"
              fi
              phase_status="DIRTY"
              phase_detail="uncommitted changes to deps"
              cascade_from="$phase"
              [ -z "$effective" ] && effective="$phase"
              all_pass=false
              update_state "$dir" "$phase" "dirty"
            fi
          fi

          if [ -z "$phase_status" ]; then
            if ! $json_mode; then
              echo "$phase: PASS"
            fi
            phase_status="PASS"
            # Set anchor on pass (only if transitioning to pass)
            current_anchor="$(git -C "$REPO_ROOT" rev-parse HEAD 2>/dev/null || true)"
            update_state "$dir" "$phase" "pass" "$current_anchor"
            anchor_for_json="$current_anchor"
          fi
        else
          if ! $json_mode; then
            echo "$phase: $status"
          fi
          phase_status="$status"
          phase_detail="$(echo "$result" | tail -n +2)"
          if [ -n "$phase_detail" ] && ! $json_mode; then
            echo "$phase_detail" | sed 's/^/  /'
          fi
          cascade_from="$phase"
          [ -z "$effective" ] && effective="$phase"
          all_pass=false
          # Determine appropriate state
          case "$status" in
            PENDING) update_state "$dir" "$phase" "pending" ;;
            FAIL)    update_state "$dir" "$phase" "fail" ;;
            *)       update_state "$dir" "$phase" "in_progress" ;;
          esac
        fi
      fi
    fi

    if [ -z "$anchor_for_json" ]; then
      anchor_for_json="$(get_state_anchor "$dir" "$phase")"
    fi

    case "$phase_status" in
      PASS) errors_json="[]" ;;
      *)
        if [ -n "$phase_detail" ]; then
          errors_json="$(json_array_from_lines "$phase_detail")"
        else
          errors_json="[]"
        fi
        ;;
    esac

    anchor_json="$(json_optional_string "$anchor_for_json")"
    item="{\"phase\":$(json_quote "$phase"),\"status\":$(json_quote "$phase_status"),\"anchor\":$anchor_json,\"errors\":$errors_json}"
    phase_items="$(json_append_item "$phase_items" "$item")"
  done

  if $json_mode; then
    if [ -n "$effective" ]; then
      effective_json="$(json_quote "$effective")"
    else
      effective_json="null"
    fi
    printf '{"feature":%s,"command":"check","effectivePhase":%s,"allPass":%s,"phases":[%s]}\n' \
      "$(json_quote "$id")" \
      "$effective_json" \
      "$all_pass" \
      "$phase_items"
  elif $all_pass; then
    echo ""
    echo "All gates pass."
  fi
}

# --- advance ---
cmd_advance() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil advance <feature-id>"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"

  # Find current phase from state.yaml
  current="$(grep '^phase:' "$dir/state.yaml" | awk '{print $2}')"

  # Validate current gate
  result="$(validate_gate "$dir" "$current")"
  status="$(echo "$result" | head -1)"

  if [ "$status" != "PASS" ]; then
    echo "Gate $current has not passed. Run 'anvil check $id' for details."
    echo "$result" | tail -n +2 | sed 's/^/  /'
    exit 1
  fi

  # Check staleness and dirty
  anchor="$(grep "  $current:" "$dir/state.yaml" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"
  if [ -n "$anchor" ]; then
    stale_result="$(check_staleness "$dir" "$current" "$anchor")"
    if [ "$stale_result" = "STALE" ]; then
      die "Gate $current is STALE — deps changed since last check. Re-verify and run 'anvil check $id'."
    fi
  fi
  dirty_result="$(check_dirty "$dir" "$current")"
  if [ "$dirty_result" = "DIRTY" ]; then
    die "Gate $current is DIRTY — uncommitted changes to deps. Commit or discard, then re-check."
  fi

  # Find next phase
  next=""
  found=false
  for phase in $PHASES; do
    if $found; then
      next="$phase"
      break
    fi
    [ "$phase" = "$current" ] && found=true
  done

  if [ -z "$next" ]; then
    echo "Feature $id is complete — already at final phase ($current)."
    exit 0
  fi

  # Set anchor and advance
  current_anchor="$(git -C "$REPO_ROOT" rev-parse HEAD 2>/dev/null || true)"
  update_state "$dir" "$current" "pass" "$current_anchor"

  # Update phase in state.yaml
  sed -i "s/^phase: .*/phase: $next/" "$dir/state.yaml"
  update_state "$dir" "$next" "in_progress"

  echo "Advanced $id: $current -> $next"
}

# --- list ---
cmd_list() {
  json_mode=false
  for arg in "$@"; do
    case "$arg" in
      --json) json_mode=true ;;
      *) die "Usage: anvil list [--json]" ;;
    esac
  done

  # Handle missing or empty features directory
  if [ ! -d "$FEATURES_DIR" ]; then
    if $json_mode; then
      printf '{"command":"list","features":[]}\n'
    fi
    exit 0
  fi

  feature_items=""
  for dir in "$FEATURES_DIR"/*/; do
    # Guard against empty glob (no matches)
    [ -d "$dir" ] || continue

    id="$(basename "$dir")"
    state="$dir/state.yaml"

    if [ ! -f "$state" ]; then
      echo "warning: $id has no state.yaml, skipping" >&2
      continue
    fi

    # Find effective phase (lowest non-PASS gate)
    effective=""
    effective_status=""
    for phase in $PHASES; do
      gate="$dir/$phase/gate.md"
      if [ ! -f "$gate" ]; then
        [ -z "$effective" ] && effective="$phase" && effective_status="MISSING"
        continue
      fi

      result="$(validate_gate "$dir" "$phase" 2>/dev/null || true)"
      gstatus="$(echo "$result" | head -1)"

      if [ "$gstatus" != "PASS" ]; then
        [ -z "$effective" ] && effective="$phase" && effective_status="$gstatus"
        continue
      fi

      # Gate passed — check staleness if anchor exists
      if [ -z "$effective" ]; then
        anchor="$(grep "  $phase:" "$state" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"
        if [ -n "$anchor" ]; then
          stale_result="$(check_staleness "$dir" "$phase" "$anchor" 2>/dev/null || true)"
          if [ "$stale_result" = "STALE" ]; then
            effective="$phase"
            effective_status="STALE"
            continue
          fi
        fi
      fi
    done

    if [ -z "$effective" ]; then
      effective="4-ship"
      effective_status="CLEAN"
    fi

    if $json_mode; then
      item="{\"feature\":$(json_quote "$id"),\"effectivePhase\":$(json_quote "$effective"),\"status\":$(json_quote "$effective_status")}"
      feature_items="$(json_append_item "$feature_items" "$item")"
    else
      echo "$id $effective $effective_status"
    fi
  done

  if $json_mode; then
    printf '{"command":"list","features":[%s]}\n' "$feature_items"
  fi
}

# --- helpers ---

# Validate a single gate file, output status on line 1, details on subsequent lines
validate_gate() {
  dir="$1"
  phase="$2"
  gate="$dir/$phase/gate.md"
  errors=""

  # 1. Check Status line
  status_line="$(grep '^Status:' "$gate" | head -1 || true)"
  if echo "$status_line" | grep -qi 'PENDING'; then
    echo "PENDING"
    echo "Gate status is PENDING"
    return 0
  fi
  if ! echo "$status_line" | grep -qi 'PASS'; then
    errors="${errors}Status line is not PASS\n"
  fi

  # 2. Check for unchecked boxes
  unchecked="$(grep -c '^\- \[ \]' "$gate" 2>/dev/null || true)"
  if [ "$unchecked" -gt 0 ]; then
    errors="${errors}$unchecked unchecked item(s)\n"
  fi

  # 3. Check Rationale is non-empty and contains a reference
  rationale="$(sed -n '/^Rationale:/,/^[A-Z]/p' "$gate" | grep -v '^Rationale:' | grep -v '^[A-Z]' | tr -d '[:space:]' || true)"
  if [ -z "$rationale" ]; then
    errors="${errors}Rationale is empty\n"
  elif ! grep -q 'Rationale:' "$gate" || ! sed -n '/^Rationale:/,/^$/p' "$gate" | grep -qE '`[^`]+`|[a-zA-Z0-9/_.-]+\.[a-zA-Z]'; then
    errors="${errors}Rationale must reference a file path or backtick-quoted term\n"
  fi

  # 4. Check produces files exist
  produces="$(sed -n 's/^produces: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for p in $produces; do
    [ -z "$p" ] && continue
    target="$dir/$phase/$p"
    if [ ! -e "$target" ]; then
      errors="${errors}Missing produced artifact: $p\n"
    fi
  done

  # 5. Check needs files exist
  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ ! -e "$target" ]; then
      errors="${errors}Missing dependency: $n\n"
    fi
  done

  # 6. For verify/ship: check Falsification section
  case "$phase" in
    2-verify|4-ship)
      if ! grep -q '^Falsification:' "$gate"; then
        errors="${errors}Missing Falsification section\n"
      elif ! grep -qE 'Tried:.*[^ ].*Observed:' "$gate" && ! (grep -q 'Tried:' "$gate" && grep -q 'Observed:' "$gate"); then
        fals_content="$(sed -n '/^Falsification:/,/^[A-Z]/p' "$gate" | grep -c 'Tried:.*→.*Observed:' || true)"
        empty_fals="$(sed -n '/^Falsification:/,/^[A-Z]/p' "$gate" | grep -c 'Tried: →' || true)"
        if [ "$fals_content" -eq 0 ] || [ "$fals_content" -eq "$empty_fals" ]; then
          errors="${errors}Falsification needs concrete Tried/Observed pairs\n"
        fi
      fi
      ;;
  esac

  if [ -n "$errors" ]; then
    echo "FAIL"
    printf "%b" "$errors"
  else
    echo "PASS"
  fi
}

# Check if needs files have uncommitted changes
check_dirty() {
  dir="$1"
  phase="$2"
  gate="$dir/$phase/gate.md"

  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ -e "$target" ] && git -C "$REPO_ROOT" diff --name-only -- "$target" 2>/dev/null | grep -q .; then
      echo "DIRTY"
      return 0
    fi
  done
  echo "CLEAN"
}

# Check if needs files changed since anchor commit
check_staleness() {
  dir="$1"
  phase="$2"
  anchor="$3"

  # Verify anchor is reachable
  if ! git -C "$REPO_ROOT" cat-file -t "$anchor" >/dev/null 2>&1; then
    echo "STALE"
    return 0
  fi

  gate="$dir/$phase/gate.md"
  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ -e "$target" ] && git -C "$REPO_ROOT" log "$anchor..HEAD" --oneline -- "$target" 2>/dev/null | grep -q .; then
      echo "STALE"
      return 0
    fi
  done
  echo "CLEAN"
}

# Update state.yaml for a phase
update_state() {
  dir="$1"
  phase="$2"
  status="$3"
  anchor="$4"

  state="$dir/state.yaml"
  [ -f "$state" ] || return 0

  if [ -n "$anchor" ]; then
    sed -i "s|  $phase: {.*}|  $phase: { status: $status, anchor: $anchor }|" "$state"
  else
    sed -i "s|  $phase: {.*}|  $phase: { status: $status }|" "$state"
  fi
}

# --- lint ---
cmd_lint() {
  id="$1"
  issues=""
  issue_count=0

  # Security: reject directory traversal
  if [ -n "$id" ]; then
    case "$id" in
      *..*)
        echo "ERROR: invalid feature ID (directory traversal rejected)" >&2
        exit 1
        ;;
    esac
  fi

  # Handle missing FEATURES_DIR
  if [ ! -d "$FEATURES_DIR" ]; then
    exit 0
  fi

  # Build list of features to lint
  if [ -n "$id" ]; then
    fdir="$(feature_dir "$id")"
    if [ ! -d "$fdir" ]; then
      echo "ERROR: Feature $id not found at $fdir" >&2
      exit 1
    fi
    feature_list="$id"
  else
    feature_list=""
    for dir in "$FEATURES_DIR"/*/; do
      [ -d "$dir" ] || continue
      fid="$(basename "$dir")"
      feature_list="$feature_list $fid"
    done
  fi

  for fid in $feature_list; do
    fdir="$(feature_dir "$fid")"

    # TMPL-STATE: check state.yaml exists
    if [ ! -f "$fdir/state.yaml" ]; then
      if [ -n "$id" ]; then
        # Specific ID requested — report as TMPL-STATE issue
        echo "$fid root TMPL-STATE state.yaml missing"
        issue_count=$((issue_count + 1))
      else
        # Scanning all features — warn and skip
        echo "warning: $fid has no state.yaml, skipping" >&2
        continue
      fi
    fi

    # TMPL-PHASE: check each phase dir and gate.md
    for phase in $PHASES; do
      pdir="$fdir/$phase"
      if [ ! -d "$pdir" ]; then
        echo "$fid $phase TMPL-PHASE phase directory missing"
        issue_count=$((issue_count + 1))
        continue
      fi
      if [ ! -f "$pdir/gate.md" ]; then
        echo "$fid $phase TMPL-PHASE gate.md missing"
        issue_count=$((issue_count + 1))
        continue
      fi

      gate="$pdir/gate.md"

      # --- GATE-FRONTMATTER ---
      has_frontmatter=false
      fm_phase=""
      fm_needs=""
      fm_produces=""
      # Check for --- delimited frontmatter
      first_line="$(sed -n '1p' "$gate")"
      if [ "$first_line" = "---" ]; then
        # Find closing ---
        closing_line="$(sed -n '2,$ { /^---$/= }' "$gate" | head -1)"
        if [ -n "$closing_line" ]; then
          has_frontmatter=true
          # Extract frontmatter fields
          fm_content="$(sed -n "2,$((closing_line - 1))p" "$gate")"
          fm_phase="$(echo "$fm_content" | sed -n 's/^phase: *//p')"
          fm_needs="$(echo "$fm_content" | sed -n 's/^needs: *\[\(.*\)\]/\1/p')"
          fm_produces="$(echo "$fm_content" | sed -n 's/^produces: *\[\(.*\)\]/\1/p')"

          if [ -z "$fm_phase" ]; then
            echo "$fid $phase GATE-FRONTMATTER frontmatter missing phase field"
            issue_count=$((issue_count + 1))
          fi
          # Check needs field exists
          if ! echo "$fm_content" | grep -q '^needs:'; then
            echo "$fid $phase GATE-FRONTMATTER frontmatter missing needs field"
            issue_count=$((issue_count + 1))
          fi
          # Check produces field exists
          if ! echo "$fm_content" | grep -q '^produces:'; then
            echo "$fid $phase GATE-FRONTMATTER frontmatter missing produces field"
            issue_count=$((issue_count + 1))
          fi
        else
          echo "$fid $phase GATE-FRONTMATTER frontmatter not properly closed with ---"
          issue_count=$((issue_count + 1))
        fi
      else
        echo "$fid $phase GATE-FRONTMATTER missing YAML frontmatter"
        issue_count=$((issue_count + 1))
      fi

      # --- GATE-STATUS ---
      status_line="$(grep '^Status:' "$gate" | head -1 || true)"
      gate_status=""
      if [ -n "$status_line" ]; then
        status_value="$(echo "$status_line" | sed 's/^Status: *//')"
        case "$status_value" in
          PENDING|PASS|FAIL) gate_status="$status_value" ;;
          *)
            echo "$fid $phase GATE-STATUS invalid status '$status_value' (must be PENDING, PASS, or FAIL)"
            issue_count=$((issue_count + 1))
            ;;
        esac
      else
        echo "$fid $phase GATE-STATUS missing Status line"
        issue_count=$((issue_count + 1))
      fi

      # --- GATE-CHECKLIST ---
      # Every line matching ^- \[ must be exactly - [ ] or - [x]
      check_lines="$(grep '^- \[' "$gate" || true)"
      if [ -n "$check_lines" ]; then
        bad_checks="$(echo "$check_lines" | grep -v '^- \[ \] ' | grep -v '^- \[x\] ' || true)"
        if [ -n "$bad_checks" ]; then
          echo "$bad_checks" | while IFS= read -r line; do
            echo "$fid $phase GATE-CHECKLIST malformed checkbox: $line"
          done
          bad_count="$(echo "$bad_checks" | wc -l | tr -d ' ')"
          issue_count=$((issue_count + bad_count))
        fi
      fi

      # --- GATE-RATIONALE (only when PASS) ---
      if [ "$gate_status" = "PASS" ]; then
        # Extract rationale content: lines after "Rationale:" until next section or EOF
        rationale_content="$(sed -n '/^Rationale:/,/^[A-Z][a-z]*:/{//!p}' "$gate" | sed '/^$/d' || true)"
        if [ -z "$rationale_content" ]; then
          # Also try: everything after Rationale: to end of file minus sections
          rationale_content="$(sed -n '/^Rationale:/{n;p;}' "$gate" | sed '/^$/d' || true)"
        fi
        if [ -z "$rationale_content" ]; then
          echo "$fid $phase GATE-RATIONALE rationale is empty but status is PASS"
          issue_count=$((issue_count + 1))
        else
          # Must contain a file ref (path.ext) or backtick-quoted term
          has_ref=false
          if echo "$rationale_content" | grep -qE '`[^`]+`'; then
            has_ref=true
          fi
          if echo "$rationale_content" | grep -qE '[a-zA-Z0-9/_.-]+\.[a-zA-Z]'; then
            has_ref=true
          fi
          if ! $has_ref; then
            echo "$fid $phase GATE-RATIONALE rationale must contain a file reference or backtick-quoted term"
            issue_count=$((issue_count + 1))
          fi
        fi
      fi

      # --- GATE-FALSIFICATION (only for 2-verify and 4-ship when PASS) ---
      case "$phase" in
        2-verify|4-ship)
          if [ "$gate_status" = "PASS" ]; then
            if ! grep -q '^Falsification:' "$gate"; then
              echo "$fid $phase GATE-FALSIFICATION missing Falsification section"
              issue_count=$((issue_count + 1))
            else
              # Must have Tried/Observed pairs with content
              fals_section="$(sed -n '/^Falsification:/,/^[A-Z][a-z]*:/p' "$gate" | grep -v '^Falsification:' | grep -v '^[A-Z][a-z]*:' || true)"
              if [ -z "$fals_section" ]; then
                fals_section="$(sed -n '/^Falsification:/,$p' "$gate" | tail -n +2 || true)"
              fi
              has_tried="$(echo "$fals_section" | grep -c 'Tried:' || true)"
              has_observed="$(echo "$fals_section" | grep -c 'Observed:' || true)"
              if [ "$has_tried" -eq 0 ] || [ "$has_observed" -eq 0 ]; then
                echo "$fid $phase GATE-FALSIFICATION missing Tried/Observed pairs"
                issue_count=$((issue_count + 1))
              fi
            fi
          fi
          ;;
      esac

      # --- XREF-NEEDS ---
      if $has_frontmatter && [ -n "$fm_needs" ]; then
        echo "$fm_needs" | tr ',' '\n' | tr -d ' ' | while IFS= read -r need_path; do
          [ -z "$need_path" ] && continue
          target="$pdir/$need_path"
          if [ ! -e "$target" ]; then
            echo "$fid $phase XREF-NEEDS needs path $need_path does not exist"
          fi
        done
      fi

      # --- XREF-PRODUCES (only when PASS) ---
      if [ "$gate_status" = "PASS" ] && $has_frontmatter && [ -n "$fm_produces" ]; then
        echo "$fm_produces" | tr ',' '\n' | tr -d ' ' | while IFS= read -r prod_path; do
          [ -z "$prod_path" ] && continue
          target="$pdir/$prod_path"
          if [ ! -e "$target" ]; then
            echo "$fid $phase XREF-PRODUCES produces path $prod_path missing but gate is PASS"
          fi
        done
      fi
    done
  done

  # Determine exit code: count actual output lines
  # Re-run in a subshell to capture output (we've been printing directly)
  # Actually, we've been printing directly to stdout, so we need a different approach
  # Let's exit based on issue_count
  if [ "$issue_count" -gt 0 ]; then
    exit 1
  fi
  exit 0
}

# --- main ---
[ $# -lt 1 ] && usage
cmd="$1"; shift

case "$cmd" in
  init)    cmd_init "$@" ;;
  status)  cmd_status "$@" ;;
  check)   cmd_check "$@" ;;
  advance) cmd_advance "$@" ;;
  list)    cmd_list "$@" ;;
  lint)    cmd_lint "$@" ;;
  *)       usage ;;
esac
