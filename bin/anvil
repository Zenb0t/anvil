#!/bin/sh
# ANVIL — Agent Navigated Verified Implementation Lifecycle
# Minimal CLI for phase-gated agentic SDLC
# Zero dependencies beyond git and POSIX shell
set -e

REPO_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
TEMPLATE_DIR="$REPO_ROOT/process/anvil/templates/feature"
FEATURES_DIR="${FEATURES_DIR:-$REPO_ROOT/work/features}"
PHASES="0-define 1-spec 2-verify 3-build 4-ship"

usage() {
  cat <<'EOF'
Usage: anvil <command> [feature-id]

Commands:
  init <id>       Scaffold a new feature from templates
  status <id>     Print phase status and blockers
  check <id>      Validate current gate (files, checklist, staleness)
  advance <id>    Move to next phase (runs check first)
  list            List all features with effective phase and gate status
  lint [<id>]     Validate process artifact format and structure

EOF
  exit 1
}

die() { echo "ERROR: $*" >&2; exit 1; }

feature_dir() { echo "$FEATURES_DIR/$1"; }

# --- init ---
cmd_init() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil init <feature-id>"
  dest="$(feature_dir "$id")"
  [ -d "$dest" ] && die "Feature $id already exists at $dest"

  cp -r "$TEMPLATE_DIR" "$dest"

  # Replace placeholder with actual feature ID
  find "$dest" -type f -name '*.md' -exec sed -i "s/{{FEATURE_ID}}/$id/g" {} +
  sed -i "s/{{FEATURE_ID}}/$id/" "$dest/state.yaml"

  echo "Feature $id scaffolded at $dest"
}

# --- status ---
cmd_status() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil status <feature-id>"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"
  [ -f "$dir/state.yaml" ] || die "No state.yaml in $dir"

  echo "Feature: $id"

  # Find effective phase (lowest non-CLEAN)
  effective=""
  for phase in $PHASES; do
    gate="$dir/$phase/gate.md"
    if [ ! -f "$gate" ]; then
      [ -z "$effective" ] && effective="$phase"
      echo "  $phase: MISSING (no gate.md)"
      continue
    fi

    result="$(validate_gate "$dir" "$phase" 2>/dev/null || true)"
    status="$(echo "$result" | head -1)"

    # Read anchor from state.yaml
    anchor="$(grep "  $phase:" "$dir/state.yaml" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"

    case "$status" in
      PASS)
        if [ -n "$effective" ]; then
          echo "  $phase: STALE (cascade from $effective)"
        elif [ -n "$anchor" ]; then
          # Check for staleness
          stale_result="$(check_staleness "$dir" "$phase" "$anchor" 2>/dev/null || true)"
          if [ "$stale_result" = "STALE" ]; then
            [ -z "$effective" ] && effective="$phase"
            echo "  $phase: STALE (deps changed since anchor $anchor)"
          else
            echo "  $phase: CLEAN (anchor: $anchor)"
          fi
        else
          echo "  $phase: PASS (no anchor)"
        fi
        ;;
      *)
        [ -z "$effective" ] && effective="$phase"
        detail="$(echo "$result" | tail -n +2 | head -3)"
        echo "  $phase: $status"
        if [ -n "$detail" ]; then
          echo "$detail" | sed 's/^/    /'
        fi
        ;;
    esac
  done

  if [ -n "$effective" ]; then
    echo ""
    echo "Effective phase: $effective"
  else
    echo ""
    echo "All phases CLEAN."
  fi
}

# --- check ---
cmd_check() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil check <feature-id>"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"

  # Validate all gates in order, cascade failures forward
  cascade_from=""
  all_pass=true

  for phase in $PHASES; do
    gate="$dir/$phase/gate.md"
    if [ ! -f "$gate" ]; then
      echo "$phase: MISSING (no gate.md)"
      [ -z "$cascade_from" ] && cascade_from="$phase"
      all_pass=false
      update_state "$dir" "$phase" "fail"
      continue
    fi

    # If upstream failed, cascade
    if [ -n "$cascade_from" ]; then
      echo "$phase: STALE (cascade from $cascade_from)"
      all_pass=false
      update_state "$dir" "$phase" "stale"
      continue
    fi

    result="$(validate_gate "$dir" "$phase")"
    status="$(echo "$result" | head -1)"

    if [ "$status" = "PASS" ]; then
      # Check staleness if anchor exists
      anchor="$(grep "  $phase:" "$dir/state.yaml" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"
      if [ -n "$anchor" ]; then
        stale_result="$(check_staleness "$dir" "$phase" "$anchor")"
        if [ "$stale_result" = "STALE" ]; then
          echo "$phase: STALE (deps changed since anchor)"
          cascade_from="$phase"
          all_pass=false
          update_state "$dir" "$phase" "stale"
          continue
        fi
      fi

      # Check dirty (uncommitted changes to needs)
      dirty_result="$(check_dirty "$dir" "$phase")"
      if [ "$dirty_result" = "DIRTY" ]; then
        echo "$phase: DIRTY (uncommitted changes to deps)"
        cascade_from="$phase"
        all_pass=false
        update_state "$dir" "$phase" "dirty"
        continue
      fi

      echo "$phase: PASS"
      # Set anchor on pass (only if transitioning to pass)
      current_anchor="$(git -C "$REPO_ROOT" rev-parse HEAD 2>/dev/null || true)"
      update_state "$dir" "$phase" "pass" "$current_anchor"
    else
      echo "$phase: $status"
      echo "$result" | tail -n +2 | sed 's/^/  /'
      cascade_from="$phase"
      all_pass=false
      # Determine appropriate state
      case "$status" in
        PENDING) update_state "$dir" "$phase" "pending" ;;
        FAIL)    update_state "$dir" "$phase" "fail" ;;
        *)       update_state "$dir" "$phase" "in_progress" ;;
      esac
    fi
  done

  if $all_pass; then
    echo ""
    echo "All gates pass."
  fi
}

# --- advance ---
cmd_advance() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil advance <feature-id>"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"

  # Find current phase from state.yaml
  current="$(grep '^phase:' "$dir/state.yaml" | awk '{print $2}')"

  # Validate current gate
  result="$(validate_gate "$dir" "$current")"
  status="$(echo "$result" | head -1)"

  if [ "$status" != "PASS" ]; then
    echo "Gate $current has not passed. Run 'anvil check $id' for details."
    echo "$result" | tail -n +2 | sed 's/^/  /'
    exit 1
  fi

  # Check staleness and dirty
  anchor="$(grep "  $current:" "$dir/state.yaml" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"
  if [ -n "$anchor" ]; then
    stale_result="$(check_staleness "$dir" "$current" "$anchor")"
    if [ "$stale_result" = "STALE" ]; then
      die "Gate $current is STALE — deps changed since last check. Re-verify and run 'anvil check $id'."
    fi
  fi
  dirty_result="$(check_dirty "$dir" "$current")"
  if [ "$dirty_result" = "DIRTY" ]; then
    die "Gate $current is DIRTY — uncommitted changes to deps. Commit or discard, then re-check."
  fi

  # Find next phase
  next=""
  found=false
  for phase in $PHASES; do
    if $found; then
      next="$phase"
      break
    fi
    [ "$phase" = "$current" ] && found=true
  done

  if [ -z "$next" ]; then
    echo "Feature $id is complete — already at final phase ($current)."
    exit 0
  fi

  # Set anchor and advance
  current_anchor="$(git -C "$REPO_ROOT" rev-parse HEAD 2>/dev/null || true)"
  update_state "$dir" "$current" "pass" "$current_anchor"

  # Update phase in state.yaml
  sed -i "s/^phase: .*/phase: $next/" "$dir/state.yaml"
  update_state "$dir" "$next" "in_progress"

  echo "Advanced $id: $current -> $next"
}

# --- list ---
cmd_list() {
  # Handle missing or empty features directory
  if [ ! -d "$FEATURES_DIR" ]; then
    exit 0
  fi

  for dir in "$FEATURES_DIR"/*/; do
    # Guard against empty glob (no matches)
    [ -d "$dir" ] || continue

    id="$(basename "$dir")"
    state="$dir/state.yaml"

    if [ ! -f "$state" ]; then
      echo "warning: $id has no state.yaml, skipping" >&2
      continue
    fi

    # Find effective phase (lowest non-PASS gate)
    effective=""
    effective_status=""
    for phase in $PHASES; do
      gate="$dir/$phase/gate.md"
      if [ ! -f "$gate" ]; then
        [ -z "$effective" ] && effective="$phase" && effective_status="MISSING"
        continue
      fi

      result="$(validate_gate "$dir" "$phase" 2>/dev/null || true)"
      gstatus="$(echo "$result" | head -1)"

      if [ "$gstatus" != "PASS" ]; then
        [ -z "$effective" ] && effective="$phase" && effective_status="$gstatus"
        continue
      fi

      # Gate passed — check staleness if anchor exists
      if [ -z "$effective" ]; then
        anchor="$(grep "  $phase:" "$state" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"
        if [ -n "$anchor" ]; then
          stale_result="$(check_staleness "$dir" "$phase" "$anchor" 2>/dev/null || true)"
          if [ "$stale_result" = "STALE" ]; then
            effective="$phase"
            effective_status="STALE"
            continue
          fi
        fi
      fi
    done

    if [ -z "$effective" ]; then
      effective="4-ship"
      effective_status="CLEAN"
    fi

    echo "$id $effective $effective_status"
  done
}

# --- helpers ---

# Validate a single gate file, output status on line 1, details on subsequent lines
validate_gate() {
  dir="$1"
  phase="$2"
  gate="$dir/$phase/gate.md"
  errors=""

  # 1. Check Status line
  status_line="$(grep '^Status:' "$gate" | head -1 || true)"
  if echo "$status_line" | grep -qi 'PENDING'; then
    echo "PENDING"
    echo "Gate status is PENDING"
    return 0
  fi
  if ! echo "$status_line" | grep -qi 'PASS'; then
    errors="${errors}Status line is not PASS\n"
  fi

  # 2. Check for unchecked boxes
  unchecked="$(grep -c '^\- \[ \]' "$gate" 2>/dev/null || true)"
  if [ "$unchecked" -gt 0 ]; then
    errors="${errors}$unchecked unchecked item(s)\n"
  fi

  # 3. Check Rationale is non-empty and contains a reference
  rationale="$(sed -n '/^Rationale:/,/^[A-Z]/p' "$gate" | grep -v '^Rationale:' | grep -v '^[A-Z]' | tr -d '[:space:]' || true)"
  if [ -z "$rationale" ]; then
    errors="${errors}Rationale is empty\n"
  elif ! grep -q 'Rationale:' "$gate" || ! sed -n '/^Rationale:/,/^$/p' "$gate" | grep -qE '`[^`]+`|[a-zA-Z0-9/_.-]+\.[a-zA-Z]'; then
    errors="${errors}Rationale must reference a file path or backtick-quoted term\n"
  fi

  # 4. Check produces files exist
  produces="$(sed -n 's/^produces: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for p in $produces; do
    [ -z "$p" ] && continue
    target="$dir/$phase/$p"
    if [ ! -e "$target" ]; then
      errors="${errors}Missing produced artifact: $p\n"
    fi
  done

  # 5. Check needs files exist
  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ ! -e "$target" ]; then
      errors="${errors}Missing dependency: $n\n"
    fi
  done

  # 6. For verify/ship: check Falsification section
  case "$phase" in
    2-verify|4-ship)
      if ! grep -q '^Falsification:' "$gate"; then
        errors="${errors}Missing Falsification section\n"
      elif [ "$(has_concrete_falsification "$gate")" != "VALID" ]; then
        errors="${errors}Falsification needs concrete Tried/Observed pairs\n"
      fi
      ;;
  esac

  if [ -n "$errors" ]; then
    echo "FAIL"
    printf "%b" "$errors"
  else
    echo "PASS"
  fi
}

# Check if needs files have uncommitted changes
check_dirty() {
  dir="$1"
  phase="$2"
  gate="$dir/$phase/gate.md"

  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ -e "$target" ] && git -C "$REPO_ROOT" diff --name-only -- "$target" 2>/dev/null | grep -q .; then
      echo "DIRTY"
      return 0
    fi
  done
  echo "CLEAN"
}

# Check if needs files changed since anchor commit
check_staleness() {
  dir="$1"
  phase="$2"
  anchor="$3"

  # Verify anchor is reachable
  if ! git -C "$REPO_ROOT" cat-file -t "$anchor" >/dev/null 2>&1; then
    echo "STALE"
    return 0
  fi

  gate="$dir/$phase/gate.md"
  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ -e "$target" ] && git -C "$REPO_ROOT" log "$anchor..HEAD" --oneline -- "$target" 2>/dev/null | grep -q .; then
      echo "STALE"
      return 0
    fi
  done
  echo "CLEAN"
}

# Validate that falsification has non-empty Tried and Observed content
has_concrete_falsification() {
  gate="$1"

  fals_section="$(sed -n '/^Falsification:/,/^[A-Z][a-z]*:/p' "$gate" | tail -n +2 | sed '$d' || true)"
  if [ -z "$fals_section" ]; then
    fals_section="$(sed -n '/^Falsification:/,$p' "$gate" | tail -n +2 || true)"
  fi

  tried_values="$(echo "$fals_section" | sed -n 's/.*Tried:[[:space:]]*//p' | sed 's/[[:space:]]*Observed:.*//' || true)"
  observed_values="$(echo "$fals_section" | sed -n 's/.*Observed:[[:space:]]*//p' || true)"

  tried_count="$(echo "$tried_values" | grep -Evc '^[[:space:]]*$' || true)"
  observed_count="$(echo "$observed_values" | grep -Evc '^[[:space:]]*$' || true)"

  if [ "$tried_count" -gt 0 ] && [ "$observed_count" -gt 0 ]; then
    echo "VALID"
  else
    echo "INVALID"
  fi
}

# Update state.yaml for a phase
update_state() {
  dir="$1"
  phase="$2"
  status="$3"
  anchor="$4"

  state="$dir/state.yaml"
  [ -f "$state" ] || return 0

  if [ -n "$anchor" ]; then
    sed -i "s|  $phase: {.*}|  $phase: { status: $status, anchor: $anchor }|" "$state"
  else
    sed -i "s|  $phase: {.*}|  $phase: { status: $status }|" "$state"
  fi
}

# --- lint ---
cmd_lint() {
  id="$1"
  issues=""
  issue_count=0

  # Security: reject directory traversal
  if [ -n "$id" ]; then
    case "$id" in
      *..*)
        echo "ERROR: invalid feature ID (directory traversal rejected)" >&2
        exit 1
        ;;
    esac
  fi

  # Handle missing FEATURES_DIR
  if [ ! -d "$FEATURES_DIR" ]; then
    exit 0
  fi

  # Build list of features to lint
  if [ -n "$id" ]; then
    fdir="$(feature_dir "$id")"
    if [ ! -d "$fdir" ]; then
      echo "ERROR: Feature $id not found at $fdir" >&2
      exit 1
    fi
    feature_list="$id"
  else
    feature_list=""
    for dir in "$FEATURES_DIR"/*/; do
      [ -d "$dir" ] || continue
      fid="$(basename "$dir")"
      feature_list="$feature_list $fid"
    done
  fi

  for fid in $feature_list; do
    fdir="$(feature_dir "$fid")"

    # TMPL-STATE: check state.yaml exists
    if [ ! -f "$fdir/state.yaml" ]; then
      if [ -n "$id" ]; then
        # Specific ID requested — report as TMPL-STATE issue
        echo "$fid root TMPL-STATE state.yaml missing"
        issue_count=$((issue_count + 1))
      else
        # Scanning all features — warn and skip
        echo "warning: $fid has no state.yaml, skipping" >&2
        continue
      fi
    fi

    # TMPL-PHASE: check each phase dir and gate.md
    for phase in $PHASES; do
      pdir="$fdir/$phase"
      if [ ! -d "$pdir" ]; then
        echo "$fid $phase TMPL-PHASE phase directory missing"
        issue_count=$((issue_count + 1))
        continue
      fi
      if [ ! -f "$pdir/gate.md" ]; then
        echo "$fid $phase TMPL-PHASE gate.md missing"
        issue_count=$((issue_count + 1))
        continue
      fi

      gate="$pdir/gate.md"

      # --- GATE-FRONTMATTER ---
      has_frontmatter=false
      fm_phase=""
      fm_needs=""
      fm_produces=""
      # Check for --- delimited frontmatter
      first_line="$(sed -n '1p' "$gate")"
      if [ "$first_line" = "---" ]; then
        # Find closing ---
        closing_line="$(sed -n '2,$ { /^---$/= }' "$gate" | head -1)"
        if [ -n "$closing_line" ]; then
          has_frontmatter=true
          # Extract frontmatter fields
          fm_content="$(sed -n "2,$((closing_line - 1))p" "$gate")"
          fm_phase="$(echo "$fm_content" | sed -n 's/^phase: *//p')"
          fm_needs="$(echo "$fm_content" | sed -n 's/^needs: *\[\(.*\)\]/\1/p')"
          fm_produces="$(echo "$fm_content" | sed -n 's/^produces: *\[\(.*\)\]/\1/p')"

          if [ -z "$fm_phase" ]; then
            echo "$fid $phase GATE-FRONTMATTER frontmatter missing phase field"
            issue_count=$((issue_count + 1))
          fi
          # Check needs field exists
          if ! echo "$fm_content" | grep -q '^needs:'; then
            echo "$fid $phase GATE-FRONTMATTER frontmatter missing needs field"
            issue_count=$((issue_count + 1))
          fi
          # Check produces field exists
          if ! echo "$fm_content" | grep -q '^produces:'; then
            echo "$fid $phase GATE-FRONTMATTER frontmatter missing produces field"
            issue_count=$((issue_count + 1))
          fi
        else
          echo "$fid $phase GATE-FRONTMATTER frontmatter not properly closed with ---"
          issue_count=$((issue_count + 1))
        fi
      else
        echo "$fid $phase GATE-FRONTMATTER missing YAML frontmatter"
        issue_count=$((issue_count + 1))
      fi

      # --- GATE-STATUS ---
      status_line="$(grep '^Status:' "$gate" | head -1 || true)"
      gate_status=""
      if [ -n "$status_line" ]; then
        status_value="$(echo "$status_line" | sed 's/^Status: *//')"
        case "$status_value" in
          PENDING|PASS|FAIL) gate_status="$status_value" ;;
          *)
            echo "$fid $phase GATE-STATUS invalid status '$status_value' (must be PENDING, PASS, or FAIL)"
            issue_count=$((issue_count + 1))
            ;;
        esac
      else
        echo "$fid $phase GATE-STATUS missing Status line"
        issue_count=$((issue_count + 1))
      fi

      # --- GATE-CHECKLIST ---
      # Every line matching ^- \[ must be exactly - [ ] or - [x]
      check_lines="$(grep '^- \[' "$gate" || true)"
      if [ -n "$check_lines" ]; then
        bad_checks="$(echo "$check_lines" | grep -v '^- \[ \] ' | grep -v '^- \[x\] ' || true)"
        if [ -n "$bad_checks" ]; then
          echo "$bad_checks" | while IFS= read -r line; do
            echo "$fid $phase GATE-CHECKLIST malformed checkbox: $line"
          done
          bad_count="$(echo "$bad_checks" | wc -l | tr -d ' ')"
          issue_count=$((issue_count + bad_count))
        fi
      fi

      # --- GATE-RATIONALE (only when PASS) ---
      if [ "$gate_status" = "PASS" ]; then
        # Extract rationale content: lines after "Rationale:" until next section or EOF
        rationale_content="$(sed -n '/^Rationale:/,/^[A-Z][a-z]*:/{//!p}' "$gate" | sed '/^$/d' || true)"
        if [ -z "$rationale_content" ]; then
          # Also try: everything after Rationale: to end of file minus sections
          rationale_content="$(sed -n '/^Rationale:/{n;p;}' "$gate" | sed '/^$/d' || true)"
        fi
        if [ -z "$rationale_content" ]; then
          echo "$fid $phase GATE-RATIONALE rationale is empty but status is PASS"
          issue_count=$((issue_count + 1))
        else
          # Must contain a file ref (path.ext) or backtick-quoted term
          has_ref=false
          if echo "$rationale_content" | grep -qE '`[^`]+`'; then
            has_ref=true
          fi
          if echo "$rationale_content" | grep -qE '[a-zA-Z0-9/_.-]+\.[a-zA-Z]'; then
            has_ref=true
          fi
          if ! $has_ref; then
            echo "$fid $phase GATE-RATIONALE rationale must contain a file reference or backtick-quoted term"
            issue_count=$((issue_count + 1))
          fi
        fi
      fi

      # --- GATE-FALSIFICATION (only for 2-verify and 4-ship when PASS) ---
      case "$phase" in
        2-verify|4-ship)
          if [ "$gate_status" = "PASS" ]; then
            if ! grep -q '^Falsification:' "$gate"; then
              echo "$fid $phase GATE-FALSIFICATION missing Falsification section"
              issue_count=$((issue_count + 1))
            else
              if [ "$(has_concrete_falsification "$gate")" != "VALID" ]; then
                echo "$fid $phase GATE-FALSIFICATION missing Tried/Observed pairs"
                issue_count=$((issue_count + 1))
              fi
            fi
          fi
          ;;
      esac

      # --- XREF-NEEDS ---
      if $has_frontmatter && [ -n "$fm_needs" ]; then
        echo "$fm_needs" | tr ',' '\n' | tr -d ' ' | while IFS= read -r need_path; do
          [ -z "$need_path" ] && continue
          target="$pdir/$need_path"
          if [ ! -e "$target" ]; then
            echo "$fid $phase XREF-NEEDS needs path $need_path does not exist"
          fi
        done
      fi

      # --- XREF-PRODUCES (only when PASS) ---
      if [ "$gate_status" = "PASS" ] && $has_frontmatter && [ -n "$fm_produces" ]; then
        echo "$fm_produces" | tr ',' '\n' | tr -d ' ' | while IFS= read -r prod_path; do
          [ -z "$prod_path" ] && continue
          target="$pdir/$prod_path"
          if [ ! -e "$target" ]; then
            echo "$fid $phase XREF-PRODUCES produces path $prod_path missing but gate is PASS"
          fi
        done
      fi
    done
  done

  # Determine exit code: count actual output lines
  # Re-run in a subshell to capture output (we've been printing directly)
  # Actually, we've been printing directly to stdout, so we need a different approach
  # Let's exit based on issue_count
  if [ "$issue_count" -gt 0 ]; then
    exit 1
  fi
  exit 0
}

# --- main ---
[ $# -lt 1 ] && usage
cmd="$1"; shift

case "$cmd" in
  init)    cmd_init "$@" ;;
  status)  cmd_status "$@" ;;
  check)   cmd_check "$@" ;;
  advance) cmd_advance "$@" ;;
  list)    cmd_list "$@" ;;
  lint)    cmd_lint "$@" ;;
  *)       usage ;;
esac
