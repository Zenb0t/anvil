#!/bin/sh
# ANVIL — Agent Navigated Verified Implementation Lifecycle
# Minimal CLI for phase-gated agentic SDLC
# Zero dependencies beyond git and POSIX shell
set -e

REPO_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
TEMPLATE_DIR="$REPO_ROOT/process/anvil/templates/feature"
FEATURES_DIR="$REPO_ROOT/work/features"
PHASES="0-define 1-spec 2-verify 3-build 4-ship"

usage() {
  cat <<'EOF'
Usage: anvil <command> [feature-id]

Commands:
  init <id>       Scaffold a new feature from templates
  status <id>     Print phase status and blockers
  check <id>      Validate current gate (files, checklist, staleness)
  advance <id>    Move to next phase (runs check first)

EOF
  exit 1
}

die() { echo "ERROR: $*" >&2; exit 1; }

feature_dir() { echo "$FEATURES_DIR/$1"; }

# --- init ---
cmd_init() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil init <feature-id>"
  dest="$(feature_dir "$id")"
  [ -d "$dest" ] && die "Feature $id already exists at $dest"

  cp -r "$TEMPLATE_DIR" "$dest"

  # Replace placeholder with actual feature ID
  find "$dest" -type f -name '*.md' -exec sed -i "s/{{FEATURE_ID}}/$id/g" {} +
  sed -i "s/{{FEATURE_ID}}/$id/" "$dest/state.yaml"

  echo "Feature $id scaffolded at $dest"
}

# --- status ---
cmd_status() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil status <feature-id>"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"
  [ -f "$dir/state.yaml" ] || die "No state.yaml in $dir"

  echo "Feature: $id"

  # Find effective phase (lowest non-CLEAN)
  effective=""
  for phase in $PHASES; do
    gate="$dir/$phase/gate.md"
    if [ ! -f "$gate" ]; then
      [ -z "$effective" ] && effective="$phase"
      echo "  $phase: MISSING (no gate.md)"
      continue
    fi

    result="$(validate_gate "$dir" "$phase" 2>/dev/null || true)"
    status="$(echo "$result" | head -1)"

    # Read anchor from state.yaml
    anchor="$(grep "  $phase:" "$dir/state.yaml" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"

    case "$status" in
      PASS)
        if [ -n "$effective" ]; then
          echo "  $phase: STALE (cascade from $effective)"
        elif [ -n "$anchor" ]; then
          # Check for staleness
          stale_result="$(check_staleness "$dir" "$phase" "$anchor" 2>/dev/null || true)"
          if [ "$stale_result" = "STALE" ]; then
            [ -z "$effective" ] && effective="$phase"
            echo "  $phase: STALE (deps changed since anchor $anchor)"
          else
            echo "  $phase: CLEAN (anchor: $anchor)"
          fi
        else
          echo "  $phase: PASS (no anchor)"
        fi
        ;;
      *)
        [ -z "$effective" ] && effective="$phase"
        detail="$(echo "$result" | tail -n +2 | head -3)"
        echo "  $phase: $status"
        if [ -n "$detail" ]; then
          echo "$detail" | sed 's/^/    /'
        fi
        ;;
    esac
  done

  if [ -n "$effective" ]; then
    echo ""
    echo "Effective phase: $effective"
  else
    echo ""
    echo "All phases CLEAN."
  fi
}

# --- check ---
cmd_check() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil check <feature-id>"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"

  # Validate all gates in order, cascade failures forward
  cascade_from=""
  all_pass=true

  for phase in $PHASES; do
    gate="$dir/$phase/gate.md"
    if [ ! -f "$gate" ]; then
      echo "$phase: MISSING (no gate.md)"
      [ -z "$cascade_from" ] && cascade_from="$phase"
      all_pass=false
      update_state "$dir" "$phase" "fail"
      continue
    fi

    # If upstream failed, cascade
    if [ -n "$cascade_from" ]; then
      echo "$phase: STALE (cascade from $cascade_from)"
      all_pass=false
      update_state "$dir" "$phase" "stale"
      continue
    fi

    result="$(validate_gate "$dir" "$phase")"
    status="$(echo "$result" | head -1)"

    if [ "$status" = "PASS" ]; then
      # Check staleness if anchor exists
      anchor="$(grep "  $phase:" "$dir/state.yaml" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"
      if [ -n "$anchor" ]; then
        stale_result="$(check_staleness "$dir" "$phase" "$anchor")"
        if [ "$stale_result" = "STALE" ]; then
          echo "$phase: STALE (deps changed since anchor)"
          cascade_from="$phase"
          all_pass=false
          update_state "$dir" "$phase" "stale"
          continue
        fi
      fi

      # Check dirty (uncommitted changes to needs)
      dirty_result="$(check_dirty "$dir" "$phase")"
      if [ "$dirty_result" = "DIRTY" ]; then
        echo "$phase: DIRTY (uncommitted changes to deps)"
        cascade_from="$phase"
        all_pass=false
        update_state "$dir" "$phase" "dirty"
        continue
      fi

      echo "$phase: PASS"
      # Set anchor on pass (only if transitioning to pass)
      current_anchor="$(git -C "$REPO_ROOT" rev-parse HEAD 2>/dev/null || true)"
      update_state "$dir" "$phase" "pass" "$current_anchor"
    else
      echo "$phase: $status"
      echo "$result" | tail -n +2 | sed 's/^/  /'
      cascade_from="$phase"
      all_pass=false
      # Determine appropriate state
      case "$status" in
        PENDING) update_state "$dir" "$phase" "pending" ;;
        FAIL)    update_state "$dir" "$phase" "fail" ;;
        *)       update_state "$dir" "$phase" "in_progress" ;;
      esac
    fi
  done

  if $all_pass; then
    echo ""
    echo "All gates pass."
  fi
}

# --- advance ---
cmd_advance() {
  id="$1"
  [ -z "$id" ] && die "Usage: anvil advance <feature-id>"
  dir="$(feature_dir "$id")"
  [ -d "$dir" ] || die "Feature $id not found at $dir"

  # Find current phase from state.yaml
  current="$(grep '^phase:' "$dir/state.yaml" | awk '{print $2}')"

  # Validate current gate
  result="$(validate_gate "$dir" "$current")"
  status="$(echo "$result" | head -1)"

  if [ "$status" != "PASS" ]; then
    echo "Gate $current has not passed. Run 'anvil check $id' for details."
    echo "$result" | tail -n +2 | sed 's/^/  /'
    exit 1
  fi

  # Check staleness and dirty
  anchor="$(grep "  $current:" "$dir/state.yaml" | grep -o 'anchor: [a-f0-9]*' | cut -d' ' -f2 || true)"
  if [ -n "$anchor" ]; then
    stale_result="$(check_staleness "$dir" "$current" "$anchor")"
    if [ "$stale_result" = "STALE" ]; then
      die "Gate $current is STALE — deps changed since last check. Re-verify and run 'anvil check $id'."
    fi
  fi
  dirty_result="$(check_dirty "$dir" "$current")"
  if [ "$dirty_result" = "DIRTY" ]; then
    die "Gate $current is DIRTY — uncommitted changes to deps. Commit or discard, then re-check."
  fi

  # Find next phase
  next=""
  found=false
  for phase in $PHASES; do
    if $found; then
      next="$phase"
      break
    fi
    [ "$phase" = "$current" ] && found=true
  done

  if [ -z "$next" ]; then
    echo "Feature $id is complete — already at final phase ($current)."
    exit 0
  fi

  # Set anchor and advance
  current_anchor="$(git -C "$REPO_ROOT" rev-parse HEAD 2>/dev/null || true)"
  update_state "$dir" "$current" "pass" "$current_anchor"

  # Update phase in state.yaml
  sed -i "s/^phase: .*/phase: $next/" "$dir/state.yaml"
  update_state "$dir" "$next" "in_progress"

  echo "Advanced $id: $current -> $next"
}

# --- helpers ---

# Validate a single gate file, output status on line 1, details on subsequent lines
validate_gate() {
  dir="$1"
  phase="$2"
  gate="$dir/$phase/gate.md"
  errors=""

  # 1. Check Status line
  status_line="$(grep '^Status:' "$gate" | head -1 || true)"
  if echo "$status_line" | grep -qi 'PENDING'; then
    echo "PENDING"
    echo "Gate status is PENDING"
    return 0
  fi
  if ! echo "$status_line" | grep -qi 'PASS'; then
    errors="${errors}Status line is not PASS\n"
  fi

  # 2. Check for unchecked boxes
  unchecked="$(grep -c '^\- \[ \]' "$gate" 2>/dev/null || true)"
  if [ "$unchecked" -gt 0 ]; then
    errors="${errors}$unchecked unchecked item(s)\n"
  fi

  # 3. Check Rationale is non-empty and contains a reference
  rationale="$(sed -n '/^Rationale:/,/^[A-Z]/p' "$gate" | grep -v '^Rationale:' | grep -v '^[A-Z]' | tr -d '[:space:]' || true)"
  if [ -z "$rationale" ]; then
    errors="${errors}Rationale is empty\n"
  elif ! grep -q 'Rationale:' "$gate" || ! sed -n '/^Rationale:/,/^$/p' "$gate" | grep -qE '`[^`]+`|[a-zA-Z0-9/_.-]+\.[a-zA-Z]'; then
    errors="${errors}Rationale must reference a file path or backtick-quoted term\n"
  fi

  # 4. Check produces files exist
  produces="$(sed -n 's/^produces: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for p in $produces; do
    [ -z "$p" ] && continue
    target="$dir/$phase/$p"
    if [ ! -e "$target" ]; then
      errors="${errors}Missing produced artifact: $p\n"
    fi
  done

  # 5. Check needs files exist
  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ ! -e "$target" ]; then
      errors="${errors}Missing dependency: $n\n"
    fi
  done

  # 6. For verify/ship: check Falsification section
  case "$phase" in
    2-verify|4-ship)
      if ! grep -q '^Falsification:' "$gate"; then
        errors="${errors}Missing Falsification section\n"
      elif ! grep -qE 'Tried:.*[^ ].*Observed:' "$gate" && ! (grep -q 'Tried:' "$gate" && grep -q 'Observed:' "$gate"); then
        fals_content="$(sed -n '/^Falsification:/,/^[A-Z]/p' "$gate" | grep -c 'Tried:.*→.*Observed:' || true)"
        empty_fals="$(sed -n '/^Falsification:/,/^[A-Z]/p' "$gate" | grep -c 'Tried: →' || true)"
        if [ "$fals_content" -eq 0 ] || [ "$fals_content" -eq "$empty_fals" ]; then
          errors="${errors}Falsification needs concrete Tried/Observed pairs\n"
        fi
      fi
      ;;
  esac

  if [ -n "$errors" ]; then
    echo "FAIL"
    printf "%b" "$errors"
  else
    echo "PASS"
  fi
}

# Check if needs files have uncommitted changes
check_dirty() {
  dir="$1"
  phase="$2"
  gate="$dir/$phase/gate.md"

  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ -e "$target" ] && git -C "$REPO_ROOT" diff --name-only -- "$target" 2>/dev/null | grep -q .; then
      echo "DIRTY"
      return 0
    fi
  done
  echo "CLEAN"
}

# Check if needs files changed since anchor commit
check_staleness() {
  dir="$1"
  phase="$2"
  anchor="$3"

  # Verify anchor is reachable
  if ! git -C "$REPO_ROOT" cat-file -t "$anchor" >/dev/null 2>&1; then
    echo "STALE"
    return 0
  fi

  gate="$dir/$phase/gate.md"
  needs="$(sed -n 's/^needs: \[\(.*\)\]/\1/p' "$gate" | tr ',' '\n' | tr -d ' []')"
  for n in $needs; do
    [ -z "$n" ] && continue
    target="$dir/$phase/$n"
    if [ -e "$target" ] && git -C "$REPO_ROOT" log "$anchor..HEAD" --oneline -- "$target" 2>/dev/null | grep -q .; then
      echo "STALE"
      return 0
    fi
  done
  echo "CLEAN"
}

# Update state.yaml for a phase
update_state() {
  dir="$1"
  phase="$2"
  status="$3"
  anchor="$4"

  state="$dir/state.yaml"
  [ -f "$state" ] || return 0

  if [ -n "$anchor" ]; then
    sed -i "s|  $phase: {.*}|  $phase: { status: $status, anchor: $anchor }|" "$state"
  else
    sed -i "s|  $phase: {.*}|  $phase: { status: $status }|" "$state"
  fi
}

# --- main ---
[ $# -lt 1 ] && usage
cmd="$1"; shift

case "$cmd" in
  init)    cmd_init "$@" ;;
  status)  cmd_status "$@" ;;
  check)   cmd_check "$@" ;;
  advance) cmd_advance "$@" ;;
  *)       usage ;;
esac
